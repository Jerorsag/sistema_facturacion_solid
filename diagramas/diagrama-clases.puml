@startuml Sistema de Facturación SOLID

' Definir paquetes
package "com.facturacion.model" {
    abstract class Producto {
        -nombre: String
        -precio: double
        +Producto(nombre: String, precio: double)
        +getNombre(): String
        +getPrecio(): double
        +toString(): String
        +equals(obj: Object): boolean
        +hashCode(): int
    }
    
    class ProductoAlimento {
        +ProductoAlimento(nombre: String, precio: double)
        +toString(): String
    }
    
    class ProductoRopa {
        +ProductoRopa(nombre: String, precio: double)
        +toString(): String
    }
    
    class ProductoElectronico {
        +ProductoElectronico(nombre: String, precio: double)
        +toString(): String
    }
    
    Producto <|-- ProductoAlimento
    Producto <|-- ProductoRopa
    Producto <|-- ProductoElectronico
}

package "com.facturacion.impuesto" {
    interface Impuesto {
        +calcularImpuesto(producto: Producto): double
        +getPorcentaje(): double
    }
    
    interface ImpuestoAlimento {
    }
    
    interface ImpuestoRopa {
    }
    
    interface ImpuestoElectronico {
    }
    
    class IVAAlimento {
        -PORCENTAJE_IVA: double = 5.0
        +calcularImpuesto(producto: Producto): double
        +getPorcentaje(): double
    }
    
    class IVARopa {
        -PORCENTAJE_IVA: double = 19.0
        +calcularImpuesto(producto: Producto): double
        +getPorcentaje(): double
    }
    
    class IVAElectronico {
        -PORCENTAJE_IVA: double = 25.0
        +calcularImpuesto(producto: Producto): double
        +getPorcentaje(): double
    }
    
    Impuesto <|-- ImpuestoAlimento
    Impuesto <|-- ImpuestoRopa
    Impuesto <|-- ImpuestoElectronico
    ImpuestoAlimento <|.. IVAAlimento
    ImpuestoRopa <|.. IVARopa
    ImpuestoElectronico <|.. IVAElectronico
}

package "com.facturacion.factura" {
    class Factura {
        -productos: List<Producto>
        -reglasImpuesto: Map<Class<? extends Producto>, Impuesto>
        +Factura(reglasImpuesto: Map<Class<? extends Producto>, Impuesto>)
        +agregarProducto(producto: Producto): void
        +calcularSubtotal(): double
        +calcularTotalImpuestos(): double
        +calcularTotal(): double
        +getProductos(): List<Producto>
        +getCantidadProductos(): int
    }
    
    interface InvoicePrinter {
        +imprimir(factura: Factura, reglasImpuesto: Map): void
    }
    
    class SimpleInvoicePrinter {
        -output: PrintStream
        +SimpleInvoicePrinter()
        +SimpleInvoicePrinter(output: PrintStream)
        +imprimir(factura: Factura, reglasImpuesto: Map): void
    }
    
    InvoicePrinter <|.. SimpleInvoicePrinter
}

package "com.facturacion.app" {
    class Main {
        +main(args: String[]): void
    }
}

' Relaciones
Factura "1" *-- "many" Producto : contiene
Factura "1" --> "many" Impuesto : usa (Map)
Main ..> Factura : crea
Main ..> ProductoAlimento : crea
Main ..> ProductoRopa : crea
Main ..> ProductoElectronico : crea
Main ..> IVAAlimento : crea
Main ..> IVARopa : crea
Main ..> IVAElectronico : crea
Main ..> SimpleInvoicePrinter : usa
SimpleInvoicePrinter ..> Factura : imprime

' Notas sobre principios SOLID
note right of Producto
  **LSP**: Las subclases pueden
  sustituir a Producto sin
  alterar comportamiento
end note

note right of Impuesto
  **DIP**: Factura depende de
  esta abstracción, no de
  implementaciones concretas
end note

note right of Factura
  **SRP**: Gestiona productos
  y calcula totales
  
  **OCP**: Extensible mediante
  Map de reglas de impuesto
  
  **DIP**: Depende de Impuesto
  (inyección por constructor)
end note

note right of InvoicePrinter
  **ISP**: Interfaz específica
  y cohesiva para impresión
end note

@enduml

